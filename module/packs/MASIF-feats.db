{"name":"Elemental Adept (Thunder)","type":"feat","img":"icons/magic/fire/projectile-fireball-purple.webp","effects":[{"_id":"Ep7NrHqaoJ5py0kF","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Elemental Adept (Thunder),all","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/fire/projectile-fireball-purple.webp","label":"Elemental Adept (Thunder)","origin":"Item.d7JuHA9yOhcz7q82","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"ddbimporter":{"featId":57,"version":"2.9.8","prerequisites":[{"description":"The ability to cast at least one spell","prerequisiteMappings":[{"id":42,"entityId":null,"entityTypeId":null,"type":"custom-value","subType":"the-ability-to-cast-at-least-one-spell","value":null,"friendlyTypeName":"Custom Value","friendlySubTypeName":"The ability to cast at least one spell"}]}]},"obsidian":{"source":{"type":"feat"}},"core":{"sourceId":"Compendium.world.ddb-feats.T47bqSNeXlJT56NH"},"scene-packer":{"hash":"82a010664e06f6d53e9a1a3f1e1c27a1dc5a3315","sourceId":"Item.hYWUDxCbqS86iwxg"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Elemental Adept (Thunder)","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.data.actionType)) return;\nconst damageType = \"thunder\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.data.data;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.data.data.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.data.data.damage.parts.length; i++) theItem.data.data.damage.parts[i] = backupItem.data.data.damage.parts[i];\n    theItem.data.data.scaling = backupItem.data.data.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Elemental Adept (Thunder)","type":"script","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv2.0 December 18 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.system.actionType)) return;\n//CHANGE DAMAGE TYPE \"acid\", \"fire\", \"cold\", \"lightning\", \"thunder\"\nconst damageType = \"thunder\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.system;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.system.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.system.damage.parts.length; i++) theItem.system.damage.parts[i] = backupItem.system.damage.parts[i];\n    theItem.system.scaling = backupItem.system.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"Player's Handbook","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"The ability to cast at least one spell","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294449,"modifiedTime":1672520414416,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"2wiIuL84iCeaVkNY"}
{"name":"Elemental Adept (Acid)","type":"feat","img":"icons/magic/acid/projectile-faceted-glob.webp","effects":[{"_id":"HlLfTD8QAW6eXGd9","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Elemental Adept (Acid),all","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/acid/projectile-faceted-glob.webp","label":"Elemental Adept (Acid)","origin":"Item.W1CFtJ3Hs6z20Gw9","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"ddbimporter":{"featId":53,"version":"2.9.8","prerequisites":[{"description":"The ability to cast at least one spell","prerequisiteMappings":[{"id":38,"entityId":null,"entityTypeId":null,"type":"custom-value","subType":"the-ability-to-cast-at-least-one-spell","value":null,"friendlyTypeName":"Custom Value","friendlySubTypeName":"The ability to cast at least one spell"}]}]},"obsidian":{"source":{"type":"feat"}},"core":{"sourceId":"Compendium.world.ddb-feats.aYmO2viJd9HdlSvF"},"scene-packer":{"hash":"fd141449107e8bce261f211627237862dd83c25c","sourceId":"Item.WE5aY0VXrvHTMatC"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Elemental Adept (Acid)","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.data.actionType)) return;\nconst damageType = \"acid\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.data.data;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.data.data.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.data.data.damage.parts.length; i++) theItem.data.data.damage.parts[i] = backupItem.data.data.damage.parts[i];\n    theItem.data.data.scaling = backupItem.data.data.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Elemental Adept (Acid)","type":"script","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv2.0 December 18 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.system.actionType)) return;\n//CHANGE DAMAGE TYPE \"acid\", \"fire\", \"cold\", \"lightning\", \"thunder\"\nconst damageType = \"acid\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.system;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.system.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.system.damage.parts.length; i++) theItem.system.damage.parts[i] = backupItem.system.damage.parts[i];\n    theItem.system.scaling = backupItem.system.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"Player's Handbook","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"The ability to cast at least one spell","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294447,"modifiedTime":1672520414402,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"7tADjfdlzKgyoulC"}
{"name":"Piercer","type":"feat","img":"icons/skills/ranged/arrow-flying-broadhead-metal.webp","effects":[{"_id":"5LsTTEo1APQ0w520","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Piercer,all","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/ranged/arrow-flying-broadhead-metal.webp","label":"Piercer","origin":"Item.Aj6rMauKBQFNOrub","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"scene-packer":{"hash":"0280c23e6da60cdaae35dd75a36c45f8839978f2","sourceId":"Item.skYBkTDPY0N425kz"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Piercer","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nPiercer\n\nUSAGE: Automatic just place on a character \n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\nif (args[0].macroPass === \"postDamageRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    const actorUuid = workflow.tokenUuid;\n    const actorToken = canvas.tokens.get(workflow.tokenId);\n    const thisItem = actorToken.actor.items.find(i => i.name === \"Piercer\")?.data;\n\n    // make sure the attempted hit was made with a weapon attack\n    if (![\"mwak\", \"rwak\"].includes(args[0].item.data.actionType)) return;\n\n    // damage type must be \"piercing\"    \n    if (workflow.defaultDamageType != \"piercing\") return;\n\n    // breakdown weapon damage to find the base die, if there was a critical, and the lowest die roll\n    let baseDie = null;\n    let lowestDieRoll = 0;\n    for (let i = 0; i < workflow.damageRoll.terms.length; i++)\n        if (workflow.damageRoll.terms[i]?.faces) {\n            baseDie = \"1d\" + workflow.damageRoll.terms[i].faces;\n            lowestDieRoll = workflow.damageRoll.terms[i].results[0].result;\n            for (let j = 0; j < workflow.damageRoll.terms[i].results.length; j++)\n                if (workflow.damageRoll.terms[i].results[j].result < lowestDieRoll) lowestDieRoll = workflow.damageRoll.terms[i].results[j].result;\n        }\n\n    // create a dialog and prompt to re-roll lowest die\n    let dialog = new Promise((resolve) => {\n        new Dialog({\n            // localize this text\n            title: \"Piercer Feat:\",\n            content: `<p>would you like to re-roll your lowest damage die?</p><p>Lowest Die Roll: ${lowestDieRoll}</p>`,\n            buttons: {\n                one: {\n                    icon: '<p> </p><img src = \"systems/dnd5e/icons/skills/arrow_01.jpg\" width=\"60\" height=\"60\"></>',\n                    label: \"<p>Yes</p>\",\n                    callback: () => resolve(true)\n                },\n                two: {\n                    icon: '<p> </p><img src = \"icons/svg/cancel.svg\" width=\"60\" height=\"60\"></>',\n                    label: \"<p>No</p>\",\n                    callback: () => { resolve(false) }\n                }\n            },\n            default: \"two\"\n        }).render(true);\n    });\n    let choice = await dialog;\n\n    if (choice) await setProperty(workflow, \"ReplaceRoll\", choice);\n    await setProperty(workflow, \"LowestRoll\", lowestDieRoll);\n    await setProperty(workflow, \"BaseDie\", baseDie);\n\n    // trigger BonusDamage to apply the extra damage / adjustments outside of the normal damage roll\n    let effectData = {\n        label: \"Piercer reRoll\",\n        changes: [{ key: \"flags.dnd5e.DamageBonusMacro\", mode: 0, value: `ItemMacro.Piercer`, priority: 20 }],\n        icon: thisItem.img,\n        origin: thisItem.uuid,\n        duration: { turns: 1 }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorUuid, effects: [effectData] });\n    return;\n\n} else if (args[0].tag === \"DamageBonus\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    const actorUuid = workflow.tokenUuid;\n    const actorToken = canvas.tokens.get(workflow.tokenId);\n    const thisItem = actorToken.actor.items.find(i => i.name === \"Piercer\")?.data;\n    const targetToken = await fromUuid(args[0].hitTargetUuids[0] ?? \"\");\n    const targetActor = targetToken.actor;\n    let choice = await getProperty(workflow, \"ReplaceRoll\");\n    let lowestDieRoll = await getProperty(workflow, \"LowestRoll\");\n    let baseDie = await getProperty(workflow, \"BaseDie\");\n    let reRoll = null;\n\n    // remove extra damage effect \n    let effect = await findEffect(actorToken, \"Piercer reRoll\");\n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: actorUuid, effects: [effect.id] });\n\n    // test if critical is true, apply extra damage die\n    if (workflow?.isCritical) {\n        reRoll = await new Roll(baseDie).roll();\n        new MidiQOL.DamageOnlyWorkflow(targetActor, targetToken, reRoll.total, \"piercing\", [targetToken], reRoll, { flavor: \"Piercer Feat: Critical Extra Damage\", itemData: thisItem, itemCardId: \"new\" });\n    }\n\n    // if reRoll was selected figure out the difference and apply adjustment to the target\n    if (choice) {\n        reRoll = await new Roll(baseDie).roll();\n        if (reRoll.result < lowestDieRoll) {\n            // healback difference\n            let difference = lowestDieRoll - reRoll.result;\n            return { damageRoll: `${difference}[healing]`, flavor: \"Piercer Feat: ReRoll Adjustment\" }\n        } else {\n            // damage difference\n            let difference = reRoll.result - lowestDieRoll;\n            return { damageRoll: `${difference}[piercing]`, flavor: \"Piercer Feat: ReRoll Adjustment\" }\n        }\n    }\n    return;\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Piercer","type":"script","scope":"global","command":"/*****\nPiercer\n\nUSAGE: Automatic just place on a character \n\nv2.0 December 18 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\nif (args[0].macroPass === \"postDamageRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    const actorUuid = workflow.tokenUuid;\n    const actorToken = canvas.tokens.get(workflow.tokenId);\n    const thisItem = actorToken.actor.items.find(i => i.name === \"Piercer\");\n    let baseDie = null;\n    let lowestDieRoll = 0;\n    let choice = false; \n\n    // make sure the attempted hit was made with a weapon attack\n    if (![\"mwak\", \"rwak\"].includes(args[0].item.system.actionType)) return;\n    console.log(\"MACRO TEST | Making Weapon Attack - PASSED\");\n\n    // damage type must be \"piercing\"    \n    if (workflow.defaultDamageType != \"piercing\") return;\n    console.log(\"MACRO TEST | Weapon is piercing - PASSED\");\n\n    // breakdown weapon damage to find the base weapon damage die and the lowest die roll\n    for (let i = 0; i < workflow.damageRoll.terms.length; i++)\n        if (workflow.damageRoll.terms[i]?.faces) {\n            baseDie = \"1d\" + workflow.damageRoll.terms[i].faces;\n            console.log(\"MACRO TEST | Base Die: %s\",baseDie);\n            lowestDieRoll = workflow.damageRoll.terms[i].results[0].result;\n            for (let j = 0; j < workflow.damageRoll.terms[i].results.length; j++)\n                if (workflow.damageRoll.terms[i].results[j].result < lowestDieRoll) lowestDieRoll = workflow.damageRoll.terms[i].results[j].result;\n        }\n\n    // check if piercer reroll was already used this turn, if true skip dialog prompt \n    if (game.combat) {\n        const combatTime = `${game.combat.id}-${game.combat.round + game.combat.turn /100}`;\n        const lastTime = actor.getFlag(\"midi-qol\", \"Piercer reRoll\");\n        \n        if (combatTime === lastTime) {\n            console.log(\"Piercer reRoll: Already done a Piercer reRoll this turn\");\n        }\n        else {\n            // create a dialog and prompt to re-roll lowest die\n            let dialog = new Promise((resolve) => {\n                new Dialog({\n                    // localize this text\n                    title: \"Piercer Feat:\",\n                    content: `<p>would you like to re-roll your lowest damage die?</p><p>Lowest Die Roll: ${lowestDieRoll}</p>`,\n                    buttons: {\n                        one: {\n                            icon: '<p> </p><img src = \"icons/skills/ranged/arrow-flying-broadhead-metal.webp\" width=\"60\" height=\"60\"></>',\n                            label: \"<p>Yes</p>\",\n                            callback: () => resolve(true)\n                        },\n                        two: {\n                            icon: '<p> </p><img src = \"icons/svg/cancel.svg\" width=\"60\" height=\"60\"></>',\n                            label: \"<p>No</p>\",\n                            callback: () => { resolve(false) }\n                        }\n                    },\n                    default: \"two\"\n                }).render(true);\n            });\n            choice = await dialog;\n            console.log(\"MACRO TEST | choice is: \" + choice);\n        }\n    }\n\n    await setProperty(workflow, \"ReplaceRoll\", choice);\n    await setProperty(workflow, \"LowestRoll\", lowestDieRoll);\n    await setProperty(workflow, \"BaseDie\", baseDie);\n\n    if (game.combat) {\n        const combatTime = `${game.combat.id}-${game.combat.round + game.combat.turn /100}`;\n        const lastTime = actor.getFlag(\"midi-qol\", \"Piercer reRoll\");\n        if (combatTime !== lastTime) {\n           await actor.setFlag(\"midi-qol\", \"Piercer reRoll\", combatTime);\n           console.log(\"MACRO TEST | Set Piercer reRoll flag to combat time\");\n        }\n      }\n    return;\n} \n\nif (args[0].tag === \"DamageBonus\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    const actorUuid = workflow.tokenUuid;\n    const actorToken = canvas.tokens.get(workflow.tokenId);\n    const thisItem = actorToken.actor.items.find(i => i.name === \"Piercer\");\n    const targetToken = await fromUuid(args[0].hitTargetUuids[0] ?? \"\");\n    const targetActor = targetToken.actor;\n    let choice = await getProperty(workflow, \"ReplaceRoll\");\n    let lowestDieRoll = await getProperty(workflow, \"LowestRoll\");\n    let baseDie = await getProperty(workflow, \"BaseDie\");\n    \n    //let diff = await getProperty(workflow, \"Difference\");\n    console.log(\"MACRO TEST | choice: %s  lowest: %s   base Die: %s\",choice, lowestDieRoll, baseDie);\n    let reRoll = null;\n    let critRoll = null;\n\n    // test if critical is true, roll extra damage die\n    if (workflow?.isCritical) {\n        console.log(\"MACRO TEST | critical!\");\n        critRoll = await new Roll(baseDie).evaluate({async: true});\n        console.log(\"MACRO TEST | critical roll extra die %O\",critRoll);\n    }\n\n    // if reRoll was selected figure out the difference and apply adjustment to the target\n    if (choice) {\n        reRoll = await new Roll(baseDie).evaluate({async: true});\n        console.log(\"MACRO TEST | ReRoll: %O\",reRoll);\n        let difference = reRoll.result - lowestDieRoll;\n        if (difference < 0) {\n            // healback difference\n            // let difference = lowestDieRoll - reRoll.result;\n            console.log(\"MACRO TEST | Difference < 0 : %s\", difference); \n            //await setProperty(workflow, \"Difference\", difference);\n            if (workflow?.isCritical)\n                return { damageRoll: `${difference}[healing] + ${critRoll.total}[piercing]`, flavor: \"Piercer Feat: ReRoll was lower + critical bonus\" }\n            else \n                return { damageRoll: `${difference}[healing]`, flavor: \"Piercer Feat: ReRoll was lower\" }\n        } else if (difference > 0) {\n            // damage difference\n            // let difference = reRoll.result - lowestDieRoll;\n            console.log(\"MACRO TEST | Difference > 0 : %s\", difference); \n            //await setProperty(workflow, \"Difference\", difference);\n            if (workflow?.isCritical)\n                return { damageRoll: `${difference}[piercing] + ${critRoll.total}[piercing]`, flavor: \"Piercer Feat: ReRoll was higher + critical bonus\" }\n            else \n                return { damageRoll: `${difference}[piercing]`, flavor: \"Piercer Feat: ReRoll was higher\" }\n        }\n    }  \n    else {    // add critical damage if it is a critcal reguardless of reroll\n        if (workflow?.isCritical)\n            return { damageRoll: `${critRoll.total}[piercing]`, flavor: \"Piercer Feat: Critical bonus\" }\n        else \n            return;   \n    }\n    return;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"core":{"sourceId":"Item.5PUe0GiheEHUomoR"},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"},"cf":{"id":"temp_b676eyusztv"},"favtab":{"isFavorite":true}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"TCoE p80","activation":{"type":"special","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Feat: Piercer","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294445,"modifiedTime":1672520414420,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"BT9bXwpMNNKaNcUe"}
{"name":"Orcish Fury","type":"feat","img":"icons/skills/social/intimidation-impressing.webp","effects":[{"_id":"YJK1tQQIV2Ycrqy0","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Orcish Fury,postDamageRoll","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/social/intimidation-impressing.webp","label":"Orcish Fury","origin":"Item.5PUe0GiheEHUomoR","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"dnd5e-helpers":{"rest-effect":"Ignore"},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"scene-packer":{"hash":"0b3ebe41bc35f3b3128b0ded22eabb7d74b41a8d","sourceId":"Item.tTE3yM6tSTBI3hxf"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Orcish Fury","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nOrcish Fury\n\nUSEAGE : AUTOMATIC\nThis item should be placed on the character that has the Orcish Fury Feat.  \nUntil used, during each melee attack the player will be prompted if they\nwant to use this ability.\n \nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \nBug fixes provided by tposney#1462 and callbritton#5405 thank you both\n*****/\n\n// make sure the attempted hit was made with a weapon attack\n\nif (![\"mwak\", \"rwak\"].includes(args[0].item.data.actionType)) return;\n\nconst pcActor = MidiQOL.MQfromActorUuid(args[0].actorUuid);\nif (args[0].hitTargetUuids.length === 0) return;\nconst target = await fromUuid(args[0].hitTargetUuids[0] ?? \"\");\n\n// check to make sure only one target is selected\nif ((args[0].targetUuids.length < 1) || (args[0].targetUuids.length > 1)) {\n    ui.notifications.error(\"You need to select a single target.\");\n    return;\n}\n\n// Find Superiority Dice Resource\nlet orcishFury = await findSheetResource(pcActor, \"Orcish Fury\");\nif (!orcishFury) {\n    ui.notifications.error(\"Could not find a resource labeled 'Orcish Fury'...\");\n    return;\n} else if (orcishFury.value < 1) return;\n\n// create a dialog and prompt to spend a superiority die\nlet dialog = new Promise((resolve) => {\n    new Dialog({\n        // localize this text\n        title: \"Orcish Fury:\",\n        content: \"<p>Use Orcish Fury for extra damage?</p>\",\n        buttons: {\n            one: {\n                icon: '<p> </p><img src = \"systems/dnd5e/icons/skills/red_01.jpg\" width=\"60\" height=\"60\"></>',\n                label: \"<p>Yes</p>\",\n                callback: () => resolve(true)\n            },\n            two: {\n                icon: '<p> </p><img src = \"systems/dnd5e/icons/skills/weapon_28.jpg\" width=\"60\" height=\"60\"></>',\n                label: \"<p>No</p>\",\n                callback: () => { resolve(false) }\n            }\n        },\n        default: \"two\"\n    }).render(true);\n});\nlet choice = await dialog;\n\nif (!choice) return;\n\n// if YES subtract a superiorty die\nawait decrimentSheetResource(pcActor, \"Orcish Fury\", 1);\n\n// get the live MIDI-QOL workflow so we can make changes\nconst diceMult = args[0].isCritical ? 2 : 1;\nlet baseDice = (1 * diceMult);\nlet die = args[0].item.data.damage.parts[0][0].split('[')[0];   // everything before the [\ndie = die.toLowerCase();                                        // convert the string to lower case\nlet baseDie = die.split('d')[1];                                //everything after the 'd' the die size and any mods\nlet furyRoll = (baseDice + \"d\" + baseDie);                          // assemble the FuryRoll\n\nconst damageType = args[0].item.data.damage.parts[0][1];        // get teh damage type from the weapon in use   \n\nreturn { damageRoll: `${furyRoll}[${damageType}]`, flavor: \"Orcish Fury\" };\n\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Test for available resource\n// Return resource object\nasync function findSheetResource(testActor, resourceName) {\n    let resources = Object.values(testActor.data.data.resources);\n    let foundResource = resources.find(i => i.label.toLowerCase() === resourceName.toLowerCase());\n    return foundResource;\n}\n\n// Decriment available resource\nasync function decrimentSheetResource(testActor, resourceName, numValue) {\n    let actorDup = duplicate(testActor);\n    let resources = Object.values(actorDup.data.resources);\n    let foundResource = resources.find(i => i.label.toLowerCase() === resourceName.toLowerCase());\n    foundResource.value = foundResource.value - numValue;\n    await testActor.update(actorDup);\n    return;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Orcish Fury","type":"script","scope":"global","command":"/*****\nOrcish Fury\n\nUSEAGE : AUTOMATIC\nThis item should be placed on the character that has the Orcish Fury Feat.  \nUntil used, during each melee attack the player will be prompted if they\nwant to use this ability.\n \nv2.0 December 18 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \nBug fixes provided by tposney#1462 and callbritton#5405 thank you both\n*****/\n\n// make sure the attempted hit was made with a weapon attack\n\nif (![\"mwak\", \"rwak\"].includes(args[0].item.system.actionType)) return;\n\nconst pcActor = MidiQOL.MQfromActorUuid(args[0].actorUuid);\nif (args[0].hitTargetUuids.length === 0) return;\nconst target = await fromUuid(args[0].hitTargetUuids[0] ?? \"\");\n\n// check to make sure only one target is selected\nif ((args[0].targetUuids.length < 1) || (args[0].targetUuids.length > 1)) {\n    ui.notifications.error(\"You need to select a single target.\");\n    return;\n}\n\n// Find Superiority Dice Resourcet\nlet orcishFury = await findSheetResource(pcActor, \"Orcish Fury\");\nif (!orcishFury) {\n    ui.notifications.error(\"Could not find a resource labeled 'Orcish Fury'...\");\n    return;\n} else if (orcishFury.value < 1) return;\n\n// create a dialog and prompt to spend a superiority die\nlet dialog = new Promise((resolve) => {\n    new Dialog({\n        // localize this text\n        title: \"Orcish Fury:\",\n        content: \"<p>Use Orcish Fury for extra damage?</p>\",\n        buttons: {\n            one: {\n                icon: '<p> </p><img src = \"icons/skills/melee/unarmed-punch-fist.webp\" width=\"60\" height=\"60\"></>',\n                label: \"<p>Yes</p>\",\n                callback: () => resolve(true)\n            },\n            two: {\n                icon: '<p> </p><img src = \"icons/svg/cancel.svg\" width=\"60\" height=\"60\"></>',\n                label: \"<p>No</p>\",\n                callback: () => { resolve(false) }\n            }\n        },\n        default: \"two\"\n    }).render(true);\n});\nlet choice = await dialog;\n\nif (!choice) return;\n\n// if YES subtract a superiorty die\nawait decrimentSheetResource(pcActor, \"Orcish Fury\", 1);\n\n// get the live MIDI-QOL workflow so we can make changes\nconst diceMult = args[0].isCritical ? 2 : 1;\nlet baseDice = (1 * diceMult);\nlet die = args[0].item.system.damage.parts[0][0].split('[')[0];  // everything before the [\ndie = die.toLowerCase();                                         // convert the string to lower case\nlet baseDie = die.split('d')[1];                                 //everything after the 'd' the die size and any mods\nlet furyRoll = (baseDice + \"d\" + baseDie);                       // assemble the FuryRoll\n\nconst damageType = args[0].item.system.damage.parts[0][1];       // get teh damage type from the weapon in use   \n\nreturn { damageRoll: `${furyRoll}[${damageType}]`, flavor: \"Orcish Fury\" };\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Test for available resource\n// Return resource object\nasync function findSheetResource(testActor, resourceName) {\n    let resources = Object.values(testActor.system.resources);\n    let foundResource = resources.find(i => i.label.toLowerCase() === resourceName.toLowerCase());\n    return foundResource;\n}\n\n// Decriment available resource\nasync function decrimentSheetResource(testActor, resourceName, numValue) {\n    const resourceKey = Object.keys(testActor.system.resources).find(k => testActor.system.resources[k].label.toLowerCase() === resourceName.toLowerCase());\n    let newResources = duplicate(testActor.system.resources);\n    newResources[resourceKey].value -= 1;\n    await actor.update({\"system.resources\": newResources});\n    return;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"core":{"sourceId":"Item.5PUe0GiheEHUomoR"},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"},"cf":{"id":"temp_b676eyusztv"},"favtab":{"isFavorite":true},"link-item-resource-5e":{"resource-link":""}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"XGtE p73","activation":{"type":"special","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"attribute","target":"","amount":1},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Feat: Orcish Fury","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294455,"modifiedTime":1672520414418,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"GokoXmKAfrt8eMoY"}
{"name":"Elemental Adept (Lightning)","type":"feat","img":"icons/magic/lightning/bolt-strike-blue.webp","effects":[{"_id":"0SBwS29D7tWLF8Yk","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Elemental Adept (Lightning),all","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/lightning/bolt-strike-blue.webp","label":"Elemental Adept (Lightning)","origin":"Item.lEyT5M1i5szqhLsu","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"ddbimporter":{"featId":56,"version":"2.9.8","prerequisites":[{"description":"The ability to cast at least one spell","prerequisiteMappings":[{"id":41,"entityId":null,"entityTypeId":null,"type":"custom-value","subType":"the-ability-to-cast-at-least-one-spell","value":null,"friendlyTypeName":"Custom Value","friendlySubTypeName":"The ability to cast at least one spell"}]}]},"obsidian":{"source":{"type":"feat"}},"core":{"sourceId":"Compendium.world.ddb-feats.s72265V0lwRI4Q42"},"scene-packer":{"hash":"978b94420090c0a07be718319e8505388b8273da","sourceId":"Item.jpf5rbVmdPHu7bFA"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Elemental Adept (Lightning)","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.data.actionType)) return;\nconst damageType = \"lightning\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.data.data;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.data.data.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.data.data.damage.parts.length; i++) theItem.data.data.damage.parts[i] = backupItem.data.data.damage.parts[i];\n    theItem.data.data.scaling = backupItem.data.data.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Elemental Adept (Lightning)","type":"script","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv2.0 December 18 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.system.actionType)) return;\n//CHANGE DAMAGE TYPE \"acid\", \"fire\", \"cold\", \"lightning\", \"thunder\"\nconst damageType = \"lightning\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.system;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.system.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.system.damage.parts.length; i++) theItem.system.damage.parts[i] = backupItem.system.damage.parts[i];\n    theItem.system.scaling = backupItem.system.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"Player's Handbook","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"The ability to cast at least one spell","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294457,"modifiedTime":1672520414411,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"Vi8aYE4J1Z6ZqYph"}
{"name":"Elemental Adept (Cold)","type":"feat","img":"icons/magic/water/projectile-ice-chunk-blue.webp","effects":[{"_id":"JqR0VfQcqj7o2sC4","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Elemental Adept (Cold),all","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/water/projectile-ice-chunk-blue.webp","label":"Elemental Adept (Cold)","origin":"Item.7Y7UQFlA6C65Hb7n","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"ddbimporter":{"featId":54,"version":"2.9.8","prerequisites":[{"description":"The ability to cast at least one spell","prerequisiteMappings":[{"id":39,"entityId":null,"entityTypeId":null,"type":"custom-value","subType":"the-ability-to-cast-at-least-one-spell","value":null,"friendlyTypeName":"Custom Value","friendlySubTypeName":"The ability to cast at least one spell"}]}]},"obsidian":{"source":{"type":"feat"}},"core":{"sourceId":"Compendium.world.ddb-feats.spxwZqUg9ypdgEug"},"scene-packer":{"hash":"f12847df27fd8a6363c5490352cf8296e7a12dbc","sourceId":"Item.cNQkuN0Osk3zRvgB"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Elemental Adept (Cold)","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.data.actionType)) return;\nconst damageType = \"cold\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.data.data;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.data.data.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.data.data.damage.parts.length; i++) theItem.data.data.damage.parts[i] = backupItem.data.data.damage.parts[i];\n    theItem.data.data.scaling = backupItem.data.data.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Elemental Adept (Cold)","type":"script","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv2.0 December 18 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.system.actionType)) return;\n//CHANGE DAMAGE TYPE \"acid\", \"fire\", \"cold\", \"lightning\", \"thunder\"\nconst damageType = \"cold\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.system;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.system.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.system.damage.parts.length; i++) theItem.system.damage.parts[i] = backupItem.system.damage.parts[i];\n    theItem.system.scaling = backupItem.system.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"Player's Handbook","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"The ability to cast at least one spell","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294451,"modifiedTime":1672520414405,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"bCgWs3xQmh83kgPy"}
{"name":"Polearm Master - Opportunity Attack","type":"feat","img":"icons/weapons/polearms/pike-flared-brown.webp","effects":[],"flags":{"ddbimporter":{"id":"903603","entityTypeId":"222216831","componentId":38,"componentTypeId":1088085227,"importId":"sreo7neodrcmv53a"},"infusions":{"infused":false},"obsidian":{"source":{"type":"feat"}},"scene-packer":{"hash":"99c09d898a30ddf4ac3aa0f181b1002e0dce837b","sourceId":"Item.TPJk7zCJHkr53kRb"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"midi-qol":{"fumbleThreshold":null,"effectActivation":false},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.be1BWQDF6EkoDFuU"},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.3"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 August 8 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>\n<p> </p>","chat":"","unidentified":""},"source":"","activation":{"type":"reaction","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":5,"long":null,"units":"ft"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"str","actionType":"","attackBonus":"0","chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false},"attunement":null},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294454,"modifiedTime":1672520414425,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"m9X8hgzx0r9L9bBl"}
{"name":"Slasher","type":"feat","img":"icons/skills/melee/blade-tips-triple-bent-white.webp","effects":[{"_id":"5LsTTEo1APQ0w520","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Slasher,preDamageRoll","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/melee/blade-tips-triple-bent-white.webp","label":"Slasher","origin":"Item.Aj6rMauKBQFNOrub","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"scene-packer":{"hash":"826e943bf7f30249c6ab19f53e13acbf3086fc40","sourceId":"Item.2RmqCkH8yzz3EMvf"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Slasher","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nSlasher\n\nUSAGE: Automatic just place on a character \n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a weapon attack\nif (![\"mwak\", \"rwak\"].includes(args[0].item.data.actionType)) return;\n\nif (args[0].macroPass === \"preDamageRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    let targetToken = await fromUuid(args[0].hitTargetUuids[0]);\n    let targetActor = targetToken.actor;\n    let theItem = workflow.item.data.data;\n\n    if (theItem.damage.parts[0][1] !== \"slashing\") return;   // not a slashing weapon  \n    else {\n        let effect = await findEffect(targetActor, \"Reduced Movement\");\n        if (!effect) await applyReduceMovementEffect(targetActor, args[0].uuid);\n        if (workflow.isCritical) await applyAttackDisadvantageEffect(targetActor, args[0].uuid);\n    }\n    return;\n}\n\n// Apply the fightened effect to the target\nasync function applyReduceMovementEffect(target, originUuid) {\n    let effectData = {\n        label: \"Reduced Movement\",\n        icon: \"systems/dnd5e/icons/items/equipment/boots-leather.jpg\",\n        origin: originUuid,\n        changes: [{ \"key\": \"data.attributes.movement.all\", \"value\": `-10`, \"mode\": 0, \"priority\": 20 }],\n        disabled: false,\n        flags: { dae: { specialDuration: [\"turnStartSource\"] }, }\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Apply the fightened effect to the target\nasync function applyAttackDisadvantageEffect(target, originUuid) {\n    let effectData = {\n        label: \"Attack Disadvantage\",\n        icon: \"systems/dnd5e/icons/skills/weapon_08.jpg\",\n        origin: originUuid,\n        changes: [{ \"key\": \"flags.midi-qol.disadvantage.attack.all\", \"value\": `1`, \"mode\": 0, \"priority\": 20 }],\n        disabled: false,\n        flags: { dae: { specialDuration: [\"turnStartSource\"] }, }\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(thisActor, effectName) {\n    let effectUuid = null;\n    effectUuid = thisActor?.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Slasher","type":"script","scope":"global","command":"/*****\nSlasher\n\nUSAGE: Automatic just place on a character \n\nv2.0 December 22 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a weapon attack\nif (![\"mwak\", \"rwak\"].includes(args[0].item.system.actionType)) return;\n\nif (args[0].macroPass === \"preDamageRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].itemUuid);\n    let targetToken = await fromUuid(args[0].hitTargetUuids[0]);\n    let targetActor = targetToken.actor;\n    let theItem = workflow.item;\n\n    if (theItem.labels.damageTypes !== \"Slashing\") return;   // not a slashing weapon  \n    else {\n        let effect = await findEffect(targetActor, \"Reduced Movement\");\n        if (!effect) await applyReduceMovementEffect(targetActor, args[0].uuid);\n        if (workflow.isCritical) await applyAttackDisadvantageEffect(targetActor, args[0].uuid);\n    }\n    return;\n}\nreturn;\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Apply the reduce movement to the target\nasync function applyReduceMovementEffect(target, originUuid) {\n    let effectData = {\n        label: \"Reduced Movement\",\n        icon: \"icons/equipment/feet/boots-leather-engraved-brown.webp\",\n        origin: originUuid,\n        changes: [{ \"key\": \"data.attributes.movement.all\", \"value\": `-10`, \"mode\": 0, \"priority\": 20 }],\n        disabled: false,\n        flags: { dae: { specialDuration: [\"turnStartSource\"] }, }\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Apply the Disadvantage effect to the target\nasync function applyAttackDisadvantageEffect(target, originUuid) {\n    let effectData = {\n        label: \"Attack Disadvantage\",\n        icon: \"icons/magic/light/beam-explosion-pink-purple.webp\",\n        origin: originUuid,\n        changes: [{ \"key\": \"flags.midi-qol.disadvantage.attack.all\", \"value\": `1`, \"mode\": 0, \"priority\": 20 }],\n        disabled: false,\n        flags: { dae: { specialDuration: [\"turnStartSource\"] }, }\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to find an effect on an actor\nasync function findEffect(thisActor, effectName) {\n    let effectUuid = null;\n    effectUuid = thisActor?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"core":{"sourceId":"Item.5PUe0GiheEHUomoR"},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"},"cf":{"id":"temp_b676eyusztv"},"favtab":{"isFavorite":true}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"TCoE p81","activation":{"type":"special","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Feat: Slasher","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294453,"modifiedTime":1672520414428,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"vIVgNEPE6Hu2Hs9d"}
{"name":"Elemental Adept (Fire)","type":"feat","img":"icons/magic/fire/projectile-embers-orange.webp","effects":[{"_id":"6pZRLDO4MLABT5r8","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Elemental Adept (Fire),all","priority":1}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/fire/projectile-embers-orange.webp","label":"Elemental Adept (Fire)","origin":"Item.c7fTdFwzwAGUSo2w","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"selfTargetAlways":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false},"effective-transferral":{"transferBlock":{"button":false,"chat":false,"displayCard":false},"transferrable":{"self":true,"target":true}}},"tint":null}],"flags":{"ddbimporter":{"featId":55,"version":"2.9.8","prerequisites":[{"description":"The ability to cast at least one spell","prerequisiteMappings":[{"id":40,"entityId":null,"entityTypeId":null,"type":"custom-value","subType":"the-ability-to-cast-at-least-one-spell","value":null,"friendlyTypeName":"Custom Value","friendlySubTypeName":"The ability to cast at least one spell"}]}]},"obsidian":{"source":{"type":"feat"}},"core":{"sourceId":"Compendium.world.ddb-feats.p2Wr0BPOrQ1FxCfv"},"scene-packer":{"hash":"e162afc8438ae38bcd0a737e9cdac0bc80a4ef62","sourceId":"Item.WTwkanKPkj5fAMpT"},"spellTemplateManager":{"stmData":{"ignoreDuration":false,"spellTexture":"","useTexture":false,"alpha":50,"coneOrigin":1,"loopAnimations":true}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Elemental Adept (Fire)","type":"script","author":"ldRsJ6Yp5qPydWA1","img":"icons/svg/dice-target.svg","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv1.0 May 7 2022 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.data.actionType)) return;\nconst damageType = \"fire\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.data.data;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.data.data.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.data.data.damage.parts.length; i++) theItem.data.data.damage.parts[i] = backupItem.data.data.damage.parts[i];\n    theItem.data.data.scaling = backupItem.data.data.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.actor.data.effects.find(ef => ef.data.label === effectName);\n    return effectUuid;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"name":"Elemental Adept (Fire)","type":"script","scope":"global","command":"/*****\nElemental Adept \n\nUSAGE: This is fully automated, just place on a character\n\nworkflow: spell damage\n    - retreive the damage type fromt thew DAE variable = damageType \n    - duplicate the ITEM on the workflow as OriginalItem\n    - search through all damage on the workfolow ITEM for the given damage type\n    - if found add \"min2\" to all damages\n    - test all targets for resistance to damageType\n    - for every target with resistance set vulnerability\n    - CLEANUP: restore the item and remove the vulnerability form all target(s)\n\nv2.0 December 18 jbowens #0415 (Discord) https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git \n*****/\n\n// make sure the attempted hit was made with a spell attack of some type\nif (![\"msak\", \"rsak\", \"save\"].includes(args[0].item.system.actionType)) return;\n//CHANGE DAMAGE TYPE \"acid\", \"fire\", \"cold\", \"lightning\", \"thunder\"\nconst damageType = \"fire\";\n\nif (args[0].macroPass === \"preItemRoll\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n\n    // backup the whole original item as a property on the workflow\n    let backupItem = theItem.clone();\n    await setProperty(workflow, \"originalItem\", backupItem);\n\n} else if (args[0].macroPass === \"preambleComplete\") {\n    const theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    let itemData = theItem.system;\n    const targets = args[0].targets;\n\n    // mark all targets that are resistant to this damage type now vulnerable to cancel the resistance\n    // replace this later with a .map function  \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        const match = targetActor.system.traits.dr.value.find(element => {\n            if (element.includes(damageType)) markTargetVulnerable(targetActor, damageType, args[0]);\n        });\n    }\n\n    // strip damage type in [] from the originalDamage if it exists and add \"min2\" and the damage type back in []\n    // replace this later with a .map function \n    for (let i = 0; i < itemData.damage.parts.length; i++) {\n        let oldDamage = itemData.damage.parts[i][1];\n        let oldDice = itemData.damage.parts[i][0];\n        if (oldDamage === damageType) {\n            let index = oldDice.indexOf('[');\n            if (index !== -1) oldDice = oldDice.slice(0, index); // remove everything after the first open bracket '['\n            itemData.damage.parts[i][1] = damageType;\n            itemData.damage.parts[i][0] = oldDice + \"min2\" + \"[\" + damageType + \"]\";\n            itemData.scaling.formula = itemData.scaling.formula + \"min2\";\n        }\n    }\n\n} else if (args[0].macroPass === \"postActiveEffects\") {\n    const workflow = MidiQOL.Workflow.getWorkflow(args[0].uuid);\n    let theItem = MidiQOL.Workflow.getWorkflow(args[0].uuid).item;\n    const targets = args[0].targets;\n\n    // remove any vulnerability previously set on target(s)\n    // replace this later with a .map function \n    for (let i = 0; i < targets.length; i++) {\n        let targetActor = targets[i].actor;\n        let effect = await findEffect(targets[i], \"EAVulnerability\");\n        if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: targetActor.uuid, effects: [effect.id] });\n    }\n\n    // restore original spell damage and scaling from the backup item\n    let backupItem = await getProperty(workflow, \"originalItem\");\n    // replace this later with a .map function \n    for (let i = 0; i < backupItem.system.damage.parts.length; i++) theItem.system.damage.parts[i] = backupItem.system.damage.parts[i];\n    theItem.system.scaling = backupItem.system.scaling;\n\n} return;\n\n// if the character has resistance to the new damage type, set vulnerability to negate it\nasync function markTargetVulnerable(target, damageType, args) {\n    const effectData = {\n        label: \"EAVulnerability\",\n        icon: \"icons/magic/defensive/barrier-shield-dome-deflect-blue.webp\",\n        origin: args.uuid,\n        changes: [{\n            \"key\": \"data.traits.dv.value\",\n            \"value\": `${damageType}`,\n            \"mode\": 2,\n            \"priority\": 20\n        }],\n        disabled: false\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.uuid, effects: [effectData] });\n}\n\n//---------------------------------- MY FUNCTIONS -------------------------------------\n\n// Function to test for an effect\nasync function findEffect(target, effectName) {\n    let effectUuid = null;\n    effectUuid = target?.effects.find(ef => ef.label === effectName);\n    return effectUuid;\n}","author":"paMZuKDupk0GHKFn","_id":null,"img":"icons/svg/dice-target.svg","folder":null,"sort":0,"ownership":{"default":0},"flags":{},"_stats":{"systemId":null,"systemVersion":null,"coreVersion":null,"createdTime":null,"modifiedTime":null,"lastModifiedBy":null}}},"exportSource":{"world":"test","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.1"}},"system":{"description":{"value":"<p>[PLACE YOUR DESCRIPTION HERE]</p>\n<p> </p>\n<details>\n<summary><strong>VERSION INFO</strong></summary>\n<p>v1.0 May 7 2022</p>\n<p>jbowens #0415 (Discord)</p>\n<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>\n</details>","chat":"","unidentified":""},"source":"Player's Handbook","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"The ability to cast at least one spell","recharge":{"value":null,"charged":false},"attunement":0},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.291","createdTime":1671193294452,"modifiedTime":1672520414408,"lastModifiedBy":"paMZuKDupk0GHKFn"},"folder":null,"sort":0,"ownership":{"default":0,"paMZuKDupk0GHKFn":3},"_id":"ynrTr55e9z1kTHwj"}

MacroPass Documentation:

    On Use Macro:           on
                            off

    ItemMacro (workflow):   preItemRoll
                            templatePlaced
                            preambleComplete
                            preSave
                            postSave
                            preDamageApplication
                            preActiveEffects
                            postActiveEffects
                            preDamageRoll
                            postDamageRoll


                            postTargeting
                            preAttack
                            preCheckHits
                            postAttack
                            

COMMON LOG TESTS
- console.log("MACRO TEST | ARGS %O  Macropass %s",args[0],args[0].macroPass);
- console.log("MACRO TEST | PC ACTOR %O",pcActor);



DAE/MIDI NOTES: 
This gives advantage to an attack if placed on a monster
Guiding Bolt
flags.midi-qol.grants.advantage.attack.all      Custom      1  

Adding a flag to your character for latter use in a script
Elemental Adept (Cold)
flags.dae                                       Custom      flagName  value

Triggering an ItemMacro with an effect at a specific time in the workflow
flags.midi-qol.onUseMacroName                   Custom      ItemMacro.Name of Macro,workflow (ex preDamageRoll) 





FOUNDRY VTT NOTES:
The data layout can be a bit confusing, the whole document piece is to facilitate the data base management and most of the time you can ignore it. 
The one case where it can bite you is when you do fromUuid(uuid) you get back the document version of the object. 
For tokens the tokens document class is TokenDocument, for actors and items it is Actor and Item - hence the special casing for token documents (sometimes).
Foundry store lots of references from one thing to another to make navigation easy.

So actor.items.getName("Longsword").parent will get you back to where you started.  
It's generally not copies but references to the object and there is only one copy of the object. 
actor.data, item.data is the actual data for the object and actor.data._source is the information stored in the database. 
[Some of the data in the actor/item is always calculated when the actor/item is updated and never store in the data base]

The labels are not a great thing to match on, since they are localised to the language the game is run in and hence can change.

CONSOLE NOTES:
For the console _token refers to the currently selected token. 
So you can do _token.actor to look at the actor data, then navigate through _token.actor.data.data to get to what you want, so
_token.actor.data.data.details.type will get the actor type field. 


GIT COMMANDS:
- VIDEO: https://www.youtube.com/watch?v=raM_Z0e7ov8
> git branch -M master
> git pull 
> git add .
> git commit -a -m'comments here'
> git push -u origin master


SETTING UP ITEMS INFO DROPDOWN

<p>&nbsp;</p>
<details>
<summary><strong>USEAGE: </strong> <span style="color: #169179;">ACTIVATE ANYTIME</span></summary>
<p>This is a utility Maneuver and can be used whenever your character can take an action.&nbsp; This will setup any bonuses and effects on the TARGET actor.&nbsp; A <span style="text-decoration: underline; color: #236fa1;">Superiority Die </span>will be expended immediately.</p>
</details>
<p>&nbsp;</p>
<details>
<summary><strong>SETUP:</strong></summary>
<p>Please remember to link the use of this ability to a character sheet resource under the item details Resource Consumption dropdown.</p>
<img width="569" alt="image" src="https://user-images.githubusercontent.com/76136571/161775726-fb67bb97-5fd1-45c5-8301-bbb17e2d0f1d.png">
</details>
<p>&nbsp;</p>
<details>
<summary><strong>VERSION INFO</strong></summary>
<p>v0.1 March 15 2022</p>
<p>jbowens #0415 (Discord)</p>
<p>https://github.com/jbowensii/More-Automated-Spells-Items-and-Feats.git</p>
</details>

JAVASCRIPT NOTES:
There is a javascript shorthand that is very useful for such things ternary operator at https://www.javascripttutorial.net/javascript-ternary-operator/
(!([creatureType?.value.toLowerCase(), creatureType?.subtype.toLowerCase()].includes(activationCondition?.toLowerCase()))) {
    console.log ("MACRO TEST | REMOVE TARGET: %O %s", target, creatureType);
    workflow.targets.delete(target);
}
you don't need the if/else construction.
The ? short circuits the lookup and the result ends up being [undefined, undefined].includes(string) which is false, which is what you want, 
since it then takes the not of that expression, so the if(expr) evaluates to true.

Array iterators are very powerful, the if else chain for the crDestroy can be replaced with a one liner
    crDestroy = [{level: 17, cr: 4}, {level: 14,cr: 3}, {level: 11., cr:2}, {level: 8, cr: 1}, {level: 5, cr: 0.5}].find(l => actorClass.levels >= l.level).cr;

also worth looking at 
.map        https://www.w3schools.com/jsref/jsref_map.asp       for each element in the array do something
.filter     https://www.w3schools.com/jsref/jsref_filter.asp    create new array of all elements of the original array that pass a test 
.reduce     https://www.w3schools.com/jsref/jsref_reduce.asp    goes through an array and performs a function resulting in a singular value for the whole array

The normal route to access actor data from a token would be:   token.actor.data.data (avoid going via _source)